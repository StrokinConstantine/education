/*
 * COMPREHENSIVE C++ OBJECT LIFETIME GUIDE
 * ======================================
 * 
 * Covers:
 * - Core object lifecycle (ctors/dtors)
 * - Special member functions
 * - Memory management
 * - Const and reference members
 * - Initialization techniques
 * - Common pitfalls
 */

#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>

/* 
 * CONSTANTS AND REFERENCES AS MEMBERS
 * ----------------------------------
 * Key constraints:
 * 1. Must initialize const/reference members in constructor initializer list
 * 2. Cannot assign to them after construction
 * 3. Classes with const/reference members cannot use default assignment operator
 * 
 * Example (from original comments):
 * int& ref_1 = g_x; // Reference must be bound immediately
 * C2(long y) : ref_1(reinterpret_cast<int&>(y)) {} // Dangling reference danger!
 * 
 * Sizeof note: References typically occupy pointer-sized storage (8 bytes on 64-bit)
 */

/*
 * DESTRUCTOR BEHAVIOR
 * -------------------
 * Important nuance:
 * - Member destructors run AFTER the class destructor body completes
 * - Thus, members are still accessible in destructor body
 * - But their own destructors haven't run yet
 * 
 * Example:
 * ~C4() {
 *   x; // Valid - x not destroyed yet
 * } // x's destructor runs here
 */

/*
 * DELETED FUNCTIONS (since C++11)
 * -------------------------------
 * Key uses:
 * 1. Prevent copying: String(const String&) = delete;
 * 2. Prevent default construction: String() = delete;
 * 3. Prevent undesirable conversions
 * 
 * Example:
 * C5() = delete; // Disables default construction
 */

/*
 * DELEGATING CONSTRUCTORS (since C++11)
 * ------------------------------------
 * Rules:
 * 1. Can only delegate to one constructor
 * 2. Can't initialize members in initializer list when delegating
 * 3. Be careful not to create constructor loops
 * 
 * Example:
 * C6(int a) : C6() { ... } // Delegates to default ctor
 */

class String {
    char* arr = nullptr;
    size_t size = 0;
    size_t capacity = 0;

public:
    // ===== CONSTRUCTORS =====
    
    /**
     * DEFAULT CONSTRUCTOR
     * -------------------
     * - Explicitly defaulted but could be omitted
     * - Will be generated by compiler if no other ctors exist
     * - Initializes members to their default values (nullptr, 0)
     */
    String() = default;

    /**
     * FILL CONSTRUCTOR
     * ----------------
     * Demonstrates:
     * - Member initializer list usage
     * - Two equivalent fill methods:
     *   1. memset - C-style, works for primitive types
     *   2. std::fill - C++ style, works for all types
     * 
     * Performance note:
     * - Both optimize to same machine code for primitives
     * - std::fill safer for non-primitives
     */
    String(size_t n, char c) : arr(new char[n + 1]), size(n), capacity(n + 1) {
        std::fill(arr, arr + size, c);
        arr[size] = '\0';
        std::cout << "Fill constructor (" << size << " x '" << c << "')\n";
    }

    /**
     * INITIALIZER_LIST CONSTRUCTOR
     * ---------------------------
     * Special {} initialization rules:
     * 1. Compiler first tries initializer_list constructor
     * 2. Then tries other constructors
     * 3. Finally attempts aggregate initialization
     * 
     * Lightweight guarantee:
     * - std::initializer_list copy doesn't copy elements
     * - Just copies pointers to the original elements
     */
    String(std::initializer_list<char> list)
        : arr(new char[list.size() + 1])
        , size(list.size())
        , capacity(size + 1) 
    {
        std::copy(list.begin(), list.end(), arr);
        arr[size] = '\0';
        std::cout << "Initializer_list constructor (" << size << " chars)\n";
    }

    // ===== COPY SEMANTICS =====
    
    /**
     * COPY CONSTRUCTOR
     * ---------------
     * Deep copy implementation choices:
     * - memcpy: Fastest for primitives, but:
     *   - No constructor calls
     *   - UB if ranges overlap
     * - std::copy: Safer alternative that:
     *   - Calls proper copy constructors
     *   - Handles overlaps correctly (uses memmove internally if needed)
     */
    String(const String& other)
        : arr(new char[other.capacity])
        , size(other.size)
        , capacity(other.capacity) 
    {
        memcpy(arr, other.arr, size + 1);
        std::cout << "Copy constructor (" << size << " chars)\n";
    }

    /**
     * COPY-AND-SWAP IDIOM
     * -------------------
     * Assignment operator implementation notes:
     * 1. Takes parameter by value (creates copy automatically)
     * 2. swap() must be noexcept for strong exception safety
     * 3. Naturally handles self-assignment
     * 
     * Contrast with traditional approach:
     * - Requires manual check for self-assignment
     * - More complex exception handling
     */
    String& operator=(String other) {
        swap(other);
        std::cout << "Assignment operator (" << size << " chars)\n";
        return *this;
    }

    void swap(String& other) noexcept {
        std::swap(arr, other.arr);
        std::swap(size, other.size);
        std::swap(capacity, other.capacity);
    }

    // ===== DESTRUCTOR =====
    ~String() {
        delete[] arr;
        std::cout << "Destructor (" << size << " chars)\n";
    }

    // ===== ELEMENT ACCESS =====
    
    /**
     * CONST-CORRECT ACCESS
     * -------------------
     * Correct implementation requires:
     * 1. Non-const version returns char&
     * 2. Const version returns const char&
     * 
     * Incorrect alternatives:
     * - char& operator[]() const:
     *   - Compiles but violates const correctness
     * - char operator[]() const:
     *   - Breaks reference semantics (&s[0] won't work)
     *   - Doesn't reflect changes to original string
     */
    char& operator[](size_t index) { return arr[index]; }
    const char& operator[](size_t index) const { return arr[index]; }

    // ===== UTILITIES =====
    void print() const {
        if (arr) std::cout << "String: \"" << arr << "\"\n";
        else std::cout << "String: [nullptr]\n";
    }
};

/*
 * CLASSES WITHOUT DEFAULT CTORS
 * ----------------------------
 * Key restriction:
 * - If a member has no default ctor, the containing class can't have one either
 * 
 * Example:
 * class NoDefault {
 *   NoDefault(bool); // No default ctor
 * };
 * 
 * class Container {
 *   NoDefault member;
 *   Container() = default; // Error!
 * };
 */

int main() {
    // Demonstrate all initialization forms
    String s1;                     // Default
    String s2(5, 'x');             // Direct
    String s3 = {'a', 'b', 'c'};   // Initializer_list
    String s4 = s3;                // Copy
    String s5{s4};                 // Also copy
    
    // Assignment cases
    s1 = s2;                       // Normal assignment
    s1 = s1;                       // Self-assignment
    
    // Const correctness demo
    const String cs("const", 5);
    // cs[0] = 'X'; // Error - good!
    char c = cs[0];  // OK
    
    // Show destructor order
    std::cout << "\n=== End of scope ===\n";
}