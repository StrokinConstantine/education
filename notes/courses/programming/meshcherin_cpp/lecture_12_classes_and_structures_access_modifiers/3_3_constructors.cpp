/*
 * Object Lifetime and Constructors/Destructors:
 * --------------------------------------------
 * - Constructor (ctor) initializes objects, destructor (dtor) cleans them up
 * - Destructors are called exactly when variable's scope ends
 * - For global variables:
 *   - Constructor runs before main()
 *   - Destructor runs after main()
 *
 * Key Differences from Managed Languages:
 * --------------------------------------
 * - C++ has no garbage collector
 * - Object destruction is deterministic (when scope ends)
 * - Unlike Java where destruction timing is unpredictable
 *
 * Compiler-Generated Functions:
 * ----------------------------
 * - Default destructor:
 *   - Calls destructors for all members (in reverse declaration order)
 *   - Can be omitted if trivial (does nothing)
 * - Default copy constructor:
 *   - Generated even if other constructors exist
 *   - Performs member-wise copy
 *
 * The Rule of Three:
 * -----------------
 * If a class requires any of these:
 * 1. Non-trivial copy constructor OR
 * 2. Non-trivial destructor OR
 * 3. Non-trivial copy assignment operator
 * Then it likely needs all three defined explicitly
 *
 * Access Control Notes:
 * --------------------
 * - Privacy checks happen after overload resolution
 * - Method accessibility is verified after selecting which function to call
 */
 
 /*
	int& ref_1 = g_x; // we can assign a variable to a reference only ony time, so string from this line ref_1 is the same as g_x 
	C2( long y ) : ref_1( reinterpret_cast<int&>( y ) ) {}  // reference to a local variable, dandling reference
	
		// only after this desctructor code, desctructor of every field will be called
		x_field; // okay, x_fields is not destroyed yet

	// assignment operator, default constructor, copy constructor, destructor = compiler can generate it

// since C++11
	// you can use = delete for functions
	
	
 sizeof of a structure with only one reference as a files = 8 ( because references are pointers on the lower level )

	// delegating constructors since C++11
	
	C6( int a ) : C6() // here you can call only one constructor and are not allowed to initialize fields here

	there is default, value, aggregate, direct, and std::initializer_list initializztions!
	~C6() = default; // we can omit this line


// char arr[10]; // array in stack as a field
*/
	
	// member initializer list

// it is common practice, to declare methods in .h file and define methods in .cpp ( if it is not template class (what to do with templates?) )

	// we can initialize constant references with rvalue, they expand lifetime of an object, but it works only for local variables of functions, not for class fields

	// C3(): ref_2( 54 ) {} // undefined behavior

	 // if there is constants or references in fields, compiler will not create operator=, but it is better to not use references and constants in a  fields ( you must initialize refs and constnats )
	 // default constructor, it will be generated by compiler if there is no constructors in class


// if we have a class with no default constructor as a field, we cannot create default constructor for our class

	// since C++11
	// the main rule: if you have at least one constructor for std::initializer_list and you create object with {}, firstly compiler try to call constructors for std::initializer_list, only then other constructor will be considered, if there is no constructors, it means aggregate initialization
	// must have if we have references or constants


//	When we are in const method, char* arr become char* const arr, so arr[i] became char&, so this method will be compiled without errors
	

// <-> std::copy, make one operation for every machine word ( for primitives )
		// std::copy calls copy constructors, memcpy just copies memory
		// strcpy copies by one byte
		// memmove gives guarantee that if there was an intersection ( memcpy will give an undefined behavior ), the result will be correct


// std::fill same efficiency as memset( arr, c, n );
		// for i < n make one operation for every byte, memset and std::fill can make one operation for every machine word ( -> in 8 times faster )

//  std::initializer_list by value, there is guarantee that std::initializer_list is lightweight type and so copying it is trivial ( copy of initializer list does not imply copy of every list element )

// for every object destructor must be call only one time, if it is not true, then it is undefined behavior
// assignment operator, default constructor, copy constructor, destructor = compiler can generate it

#include<iostream>
#include<vector>
#include<cstring>
#include<algorithm>



class String
{
	char* arr = nullptr;
	size_t size = 0;
	size_t capacity = 0;
	
public:
	
	String() = default;
	
	
	
	String( size_t n, char c ): arr( new char[n + 1] ), size( n ), capacity( n + 1 )
	
	
	{
		memset( arr, c, n ); // godbolt
		
		std::fill( arr, arr + size, c ); /
		arr[size] = '\0';
			std::cout << "constructor 1" << std::endl;
	}
	

	String( std::initializer_list<char> list )
		: arr( new char[list.size() + 1] )
		, size( list.size() )
		, capacity( size + 1 )
		{
			std::copy( list.begin(), list.end(), arr );
			arr[size] = '\0';
			std::cout << "init list" << std::endl;
		}
	
	~String() 
	{
		delete[] arr;
	}
	
	String( const String& other ): arr( new char[other.capacity] ), size( other.size ), capacity( other.capacity )
	{
		memcpy( arr, other.arr, size + 1 ); 
	}
	
	
	char& operator[](size_t index)
	{
	


	// Implementation using copy and swap idiom
	String& operator=( String other )
	{
		swap(other);
		return *this;
	}
	
	void swap( String& other )
	{
		std::swap(arr, other.arr); // O(1)
		std::swap(size, other.size); // O(1)
		std::swap(capacity, other.capacity); // O(1)
	}
	
		return arr[index];
	}
	
	const char& operator[](size_t index) const
	{
		return arr[index];
	}
	
};






int main()
{
	
	// class_with_class_with_no_default_constructor_class_as_a_field a;
	
	String sss = {'a', 'b', 'c', 'd'};
	const String& cs = sss;
	const char& cc = cs[0];
	// there is also should be two versions for cs.front() and cs.back() for const and non-const strings
	sss[0] = 'b';
	
	// class String s23 = s23; // undefined behavior, copy constructor call

	int x{5}; // initialization


	String s11 = {'d', 'd'};
	String s22 = s11; // if you do not create copy constructor it is undefined behavior
	

	
	//std::cout << sizeof( C2 ) << std::endl; 
	
	String string; // default initialization
	
	String s = {'a', 'b'}; // initializer list
	String s2{2, 'b'}; // initializer list
	String s3(2, 'b'); // simple constructor
	
	s = s3; // call of operator=( const String& ),undefined behavior ( double free and memory leak )
	s = s; // you can call some function that returns reference to s, so this line should work
	std::vector<int> v = {4, 2, 76, 3, 1}; // {} may mean: aggregate initialization, constructor call, std::initializer list
	

}