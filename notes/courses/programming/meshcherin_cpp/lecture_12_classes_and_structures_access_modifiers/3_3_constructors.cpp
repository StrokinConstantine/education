/*
	constructor ctor/dtor destructor


*/

#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>

class ComplexNumber
{
	double re = 0.0;
	double im = 0.0;
	
public:
	
	ComplexNumber( double real )
	{
		re = real; // firstly we initialize re with 0 ( default constructor call ) , then we assign real to re
	}
	
	// member initializer list
	ComplexNumber( float re ): re(re) // here we only initialize re 
	{
		
	}
	
	ComplexNumber( double re, double im ): re(re), im(im) {}
	
	// ComplexNumber( double re, double im ): im(im), re(re) {} // warning
	
	ComplexNumber( float r, float phi );
	
};


// it is common practice, to declare methods in .h file and define methods in .cpp ( if it is not template class )
ComplexNumber::ComplexNumber( float r, float phi ): re( r ), im( r ){}


class String
{
	char* arr = nullptr;
	size_t size = 0;
	size_t capacity = 0;
	
public:
	
	String() = default; // explicitly declared, implicitly defined default constructor
	
	// implicitly declared default constructor initializes fields with default values
	String() {} // default constructor, it will be generated by compiler if there is no constructors
	String( size_t n, char c ): arr( new char[n + 1] ), size( n ), capacity( n + 1 )
	{
		memset( arr, c, n ); // godbolt
		std::fill( arr, arr + size, c ); // same efficiency as memset( arr, c, n );
		// for i < n make one operation for every byte, memset and std::fill can make one operation for every machine word ( -> in 8 times faster )
		arr[size] = '\0';
			std::cout << "constructor 1" << std::endl;
	}
	
	// since C++11
	// the main rule: if you have at least one constructor for std::initializer_list and you create object with {}, firstly compiler try to call constructors for std::initializer_list, only then other constructor will be considered, if there is no constructors, it means aggregate initialization
	String( std::initializer_list<char> list ) // by value, there is guarantee that std::initializer_list is lightweight type and so copying it is trivial ( copy of initializer list does not imply copy of every list element )
		: arr( new char[list.size() + 1] )
		, size( list.size() )
		, capacity( size + 1 )
		{
			std::copy( list.begin(), list.end(), arr );
			arr[size] = '\0';
			std::cout << "init list" << std::endl;
		}
	
};

int main()
{
	String string; // default initialization
	
	String s = {'a', 'b'}; // initializer list
	String s2{2, 'b'}; // initializer list
	String s3(2, 'b'); // simple constructor
	
	
	std::vector<int> v = {4, 2, 76, 3, 1}; // {} may mean: aggregate initialization, constructor call, std::initializer list
	
	ComplexNumber c(5.0); // direct initialization
	ComplexNumber c2 = 5.0; // value initialization 
	ComplexNumber c3{5.0}; // ... initialization
	ComplexNumber c4 = {5.0};
	
	ComplexNumber c5{1.0,2.0}; // if there is at least one constructor, this is not aggregate initialization, it is constructor call
	
	

}