/*
	constructor ctor/dtor destructor
	destructors are called just before lifefime of variable ends ( scope of variable ends )
	if class has a trivial destructor, omit its definition
	lifefime of an object / scope of variable
	for global variable constructor is called before main(), and destructor is called after main()
	in C++ there is no garbage collector, so we know deterministically when destructors are called ( when scope of variable ends ), in Java we do not know when object will be destroyed 
	default destructor calls destructor of every field in reverse order
	compiler generates copy constructor by default, even if you have another constructors
	privateness is checking after overloading
	the function of three: if class has a non-trivial copy constructor, or non-trivial desctructor, or non-trivial operator=, you must define all of this
*/

#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>

class ComplexNumber
{
	double re = 0.0;
	double im = 0.0;
	
public:
	
	ComplexNumber( double real )
	{
		// fields are already initialized here
		re = real; // firstly we initialize re with 0 ( default constructor call ) , then we assign real to re
	}
	
	// member initializer list
	ComplexNumber( float re ): re(re) // here we only initialize re 
	{
		
	}
	
	ComplexNumber( double re, double im ): re(re), im(im) {}
	
	// ComplexNumber( double re, double im ): im(im), re(re) {} // warning
	
	ComplexNumber( float r, float phi );
	
};


// it is common practice, to declare methods in .h file and define methods in .cpp ( if it is not template class )
ComplexNumber::ComplexNumber( float r, float phi ): re( r ), im( r ){}


class String
{
	char* arr = nullptr;
	size_t size = 0;
	size_t capacity = 0;
	
public:
	
	String() = default; // explicitly declared, implicitly defined default constructor
	
	// implicitly declared default constructor initializes fields with default values
	// String() {} // default constructor, it will be generated by compiler if there is no constructors
	String( size_t n, char c ): arr( new char[n + 1] ), size( n ), capacity( n + 1 )
	{
		memset( arr, c, n ); // godbolt
		std::fill( arr, arr + size, c ); // same efficiency as memset( arr, c, n );
		// for i < n make one operation for every byte, memset and std::fill can make one operation for every machine word ( -> in 8 times faster )
		arr[size] = '\0';
			std::cout << "constructor 1" << std::endl;
	}
	
	// since C++11
	// the main rule: if you have at least one constructor for std::initializer_list and you create object with {}, firstly compiler try to call constructors for std::initializer_list, only then other constructor will be considered, if there is no constructors, it means aggregate initialization
	// must have if we have references or constants
	String( std::initializer_list<char> list ) // by value, there is guarantee that std::initializer_list is lightweight type and so copying it is trivial ( copy of initializer list does not imply copy of every list element )
		: arr( new char[list.size() + 1] )
		, size( list.size() )
		, capacity( size + 1 )
		{
			std::copy( list.begin(), list.end(), arr );
			arr[size] = '\0';
			std::cout << "init list" << std::endl;
		}
	
	~String() // for every object destructor must be call only one time, if it is not true, then it is undefined behavior
	{
		delete[] arr;
	}
	
	String( const String& other ): arr( new char[other.capacity] ), size( other.size ), capacity( other.capacity )
	{
		memcpy( arr, other.arr, size + 1 ); // <-> std::copy, make one operation for every machine word ( for primitives )
		// std::copy calls copy constructors, memcpy just copies memory
		// strcpy copies by one byte
		// memmove gives guarantee that if there was an intersection ( memcpy will give an undefined behavior ), the result will be correct
	}
	// COW = copy on write ( lazy copy ) = leave trivial copy costructor and create actual copy on write attempts
	// COW string
	
	// assignment operator, default constructor, copy constructor, destructor = compiler can generate it
	



	//	String& operator= ( const String& other )
	// : ... // error, this is not contructor
	//{
		/*
		if ( this == &other ) return *this;
		
		//this->~String(); // undefined behavior, compiler: destructor call, okay, then following expressions can be deleted
		delete[] arr;
		size = other.size;
		capacity = other.capacity;
		arr = new char[other.cap];
		memcpy(arr, other.arr, size + 1);
		return *this;
		*/
		
		// copy and swap idiom
		// correct work with exceptions
	//	String copy = other;
	//	swap(copy);
	//	return *this;
		
	//}


	String& operator=( String other )
	{
		swap(other);
		return *this;
	}
	
	void swap( String& other )
	{
		std::swap(arr, other.arr); // O(1)
		std::swap(size, other.size); // O(1)
		std::swap(capacity, other.capacity); // O(1)
	}
	
	// return String -> copy constructor
	
};



class C1
{
	int& int_ref_1; // we must initialize int_ref_1
	const int c; // we must initialize c
	
	// if we have a class with no default constructor as a field, we cannot create default constructor for our class
	
	C1() = default;
	C1( const C1& ) = default;
	/*
		error: uninitialized reference member in ‘class C1’
		error: uninitialized const member in ‘class C1’
	*/
};

int g_x;

class C2
{
	int& ref_1 = g_x; // we can assign a variable to a reference only ony time, so string from this line ref_1 is the same as g_x 
	
	C2( int y )
	{
		ref_1 = y; // g_x = y
	}
	
	C2( long y ) : ref_1( reinterpret_cast<int&>( y ) ) {}  // reference to a local variable, dandling reference

};

class C3
{
public:

	 const int& ref_2;
	
	// we can initialize constant references with rvalue, they expand lifetime of an object, but it works only for local variables of functions
	C3(): ref_2( 54 ) {} // undefined behavior

	C3& operator=(  const C3& other ) = default; // if there is constants or references in fields, compiler will not create operator=, but it is better to not use references and constants in a  fields
};


class C4
{
	int x;
	
public:
	C4()
	{
		std::cout << "C4 ctor" << std::endl;
	}

	~C4()
	{
		std::cout << "C4 dtor" << std::endl;
		// only after this desctructor code, desctructor of every field will be called
		x; // okay, x is not destroyed yet
	}
};

class C5
{

public:

	//C5()
	//{
	//	std::cout << "C5 ctor" << std::endl;
	//}
	
	~C5()
	{
		// C5(); // error: use of deleted function ‘C5::C5()’
		std::cout << "C5 dtor" << std::endl;
	}
	
	C5( const C5& other ); // copy constructor
	C5( C5& other ); // copy constructor, will not be generated
	C5() = delete; // since C++11
	// you can use = delete for functions
	
	
};

class C6
{
private:

	C6()
	{
		std::cout << "C6 ctor" << std::endl;
	}
	
public:


	// delegating constructors since C++11
	
	C6( int a ) : C6() // here you can call only one constructor and are not allowed to initialize fields here
	{
		C6(); // creates temporary string here
		// this->C6(); // error: invalid use of C6::C
		std::cout << "C6 delegating constructor" << std::endl;
	}
	
	~C6() = default; // we can omit this line
};



int main()
{
	
	class C3 my_c3_1;
	class C3 my_c3_2;
	
	my_c3_1 = my_c3_2;
	
	
	// class String s23 = s23; // undefined behavior, copy constructor call
	class C4 c44;
	// C5 c55; // error: use of deleted function ‘C5::C5()’
	
	// c55.~C5(); // undefined behavior
	// c55.C5(); // error: invalid use of ‘C5::C5’
	
	C3 c34;
	
	class C6 c66( 2 );
	std::cout << c34.ref_2;
	
	String s11 = {'d', 'd'};
	String s22 = s11; // if you do not create copy constructor it is undefined behavior
	
	// C1 c1; // error: use of deleted function ‘C1::C1()’
	
	std::cout << sizeof( C2 ) << std::endl; // 8 ( because references are pointers on the lower level )
	
	String string; // default initialization
	
	String s = {'a', 'b'}; // initializer list
	String s2{2, 'b'}; // initializer list
	String s3(2, 'b'); // simple constructor
	
	s = s3; // call of operator=( const String& ),undefined behavior ( double free and memory leak )
	s = s; // you can call some function that returns reference to s, so this line should work
	std::vector<int> v = {4, 2, 76, 3, 1}; // {} may mean: aggregate initialization, constructor call, std::initializer list
	
	ComplexNumber c(5.0); // direct initialization
	ComplexNumber c2 = 5.0; // value initialization 
	ComplexNumber c3{5.0}; // ... initialization
	ComplexNumber c4 = {5.0};
	
	ComplexNumber c5{1.0,2.0}; // if there is at least one constructor, this is not aggregate initialization, it is constructor call
	
	

}