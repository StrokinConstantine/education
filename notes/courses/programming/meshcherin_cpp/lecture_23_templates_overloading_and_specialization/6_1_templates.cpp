#include <iostream>
#include <map>
// same code for different types ( templates in C++ = generics in Java )

// propositional logic -> first order logic


// template <class T> the same as template <typename T>

template <typename T> // quantifier ( for every type T ), meta-parameter



void swap( T& x, T& y ) // O( 3*n ) for strings
{
	T t = x;
	x = y;
	y = t;
}

template <typename T>
T max( T x, T y ) // template function
{
	return x > y ? x : y;
}

template <typename T>
class vector // template class
{
	T* arr;
	size_t size;
	size_t capacity;
};



template <typename T>
struct less
{
		bool operator()( const T& x, const T& y ) const 
		{
			return x < y;
		}
};

template <typename T>
struct greater
{
		bool operator()( const T& x, const T& y ) const 
		{
			return x > y;
		}
};

// since C++11 template using
template <typename T> // code style: (T), (U, V)
using mymap = std::map<T, T, std::greater<T>>; // in std::greater (T, T) <-> T < T? 

mymap<int> m;

// since C++14 constant template variables

// since C++20 template concept

int main()
{
	int a = 0; 
	long long b = 1;
	int c = 2;
	long long d;
	// swap( a, b ); // error: no matching function for call to
	
	swap(a, c);
	swap(b, d);
	
	
	swap<long long>( b, d);
	
	// swap<long long>( a, d); // we cannot initialize non-constant reference with rvalue
	
	
	
	// compiler will generate two different functions with different addresses with the same pattern
	
	/*
	first task of compiler: for which type T generate swap( , )?
	second task: which conversion is better?
	
	( choice of template (template overloading resolution) ( or decision that template is not needed ) -> template instantiation -> overloading resolution of everyting ( between generated code and functions ) )
	
	templates = code generation
	
	templates is not a code, it is pattern with which code will be generated by compiler
	
	first compilation stage: for which types generate templates? (template code generation)
	*/
	
	// two classes will be generated:
	// vector<int>; // error: declaration does not declare anything
	vector<int> aa;
	vector<double> bb;
	
	// aa = bb; // error: no match for ‘operator=’ (operand types are ‘vector<int>’ and ‘vector<double>’)
	
}